To solve the puzzle with recursion, the first thing to do is break the original problem down into smaller sub-problems.

The final configuration with n disks piled up to the third rod in decreasing order can be obtained by moving:

n - 1 disks from the source to the auxiliary rod
the largest disk from the source to the target
and then the n - 1 disks from the auxiliary rod to the target.
So, the first thing the move function should do is calling itself with n - 1 as the first argument. But if you try to do so without defining a base case, you will get a RecursionError. This happens because the function keeps calling itself indefinitely.

Before your comment and your print() call, add the recursive function call with n - 1 as the first argument and make sure the function body executes only when n is greater than zero. For now, leave the other arguments in the same order.

The steps of moving n - 1 disks can be broken down further until only a single disk is considered. This will be the first move occurring. After the first move occurs, the following moves are generated by the unwinding of the recursive calls. Keep in mind that in each recursive step the role played by the rods changes between source, target, and auxiliary.

For now, each recursive call prints the rods dictionary without performing any changes to the lists. Before the print() call, remove the last element from the rods[source] list and append it to the rods[target] list.